# Campus Events and Entertainment Center

## Team 11

|**Name**|**Student ID**|
|:----|:----|
| 李冰   | 12110141   |
| 张颖萍 | 12111947   |
| 李华炫 | 12112045   |
| 陶毅诚 | 12112003   |
| 秦尧   | 12112016   |

# Metrics

## Lines of Code

We use **PMD** to calculate this metric.

## NcssCount

>This rule uses the NCSS (Non-Commenting Source Statements) metric to determine the number of lines of code in a class, method or constructor. NCSS ignores comments, blank lines, and only counts actual statements. For more details on the calculation, see the documentation of the [NCSS metric](https://docs.pmd-code.org/pmd-doc-6.55.0/pmd_java_metrics_index.html#non-commenting-source-statements-ncss).
The results are too long and can be viewed in `Line_of_Code_Results.pdf`.

## Number of packages/modules 

We use **Maven-Javadoc-Plugin** to calculate this metric.

Number of packages/modules: 10

![](/assets/pkg.png)

## Number of source files 

We use **Statistic** Plugin from IDEA to calculate this metric.

Java file: 164

Python file: 5

Vue file: 62

![](/assets/src.png)

## Number of dependencies

We use **Maven-Project-Info-Reports-Plugin**to calculate this metric.

Num of dependencies: 51

![](/assets/dep1.png)

![](/assets/dep2.png)

# Documentation

## Documentation for end users(Chinese)

USER

[https://sustecheventcenter.gitbook.io/user](https://sustecheventcenter.gitbook.io/user)

ADMIN

[https://sustecheventcenter.gitbook.io/admin](https://sustecheventcenter.gitbook.io/admin)

## Documentation for developers(Swagger Doc)

[http://47.107.113.54:25571/swagger-ui/index.html](http://47.107.113.54:25571/swagger-ui/index.html)

# Tests

## Automated Testing for Quality Assurance

### Technology/Tools/Frameworks/Approaches Used

For the automated testing of our project, we utilized the following tools and frameworks:

1. **JUnit**: For unit testing our Java code, ensuring that individual units of source code (methods) work as expected.
2. **Mockito**: For mocking dependencies in our unit tests, which helps in isolating the class being tested and focusing on its behavior.
3. **Github Action**: For continuous integration (CI), where automated tests are run on each commit to the repository to ensure that new changes do not break existing functionality.
4. **Jacoco**: For generating code coverage reports, helping us understand how much of our code is being tested by our automated tests.
### Source Code and Related Artifacts for Testing

All the source code are in **backend/src/test/java/org/cs304/backend**.

#### Effectiveness of Tests

To evaluate the effectiveness of our tests, we use test coverage reports generated by Jacoco. These reports provide a detailed analysis of how much of our codebase is exercised by our tests.

#### Coverage Report

We focus our tests on backend service implementation and REST API services (controllers), as these are where the main business logic occurs. Other parts of the code, such as those generated automatically by Lombok, do not require testing, or are too fragmented and frequently changing to be suitable for writing tests.

Additionally, for code that doesn't involve core business logic, such as simple model classes or DTOs (Data Transfer Objects), we do not write individual tests. Our testing strategy prioritizes ensuring the stability and reliability of core functionalities. This approach maximizes test coverage and effectiveness within limited resources. For code that changes frequently, we rely on manual testing and code reviews to ensure quality and correctness.

By focusing on these key areas, we ensure thorough testing of critical business logic while remaining flexible enough to handle frequent code changes, thereby improving overall development efficiency and code quality.

![](/assets/test.png)

The high percentages in line and method coverage indicate that the majority of our code is being tested. The branch coverage, while slightly lower, suggests that there are still some conditional paths that could be further tested.

### Manual Testing Approach

Since automation was not feasible for certain parts of the project, we resorted to manual testing. The difficulties in test automation typically included:

* **Dynamic UI Elements**: The UI were highly dynamic and difficult to automate reliably.
* **Third-Party Integrations**: Interfacing with third-party services that could not be easily mocked or simulated in a test environment.
#### Steps for Manual Testing

1. **Test Plan Creation**: Detailed test cases were created to cover all possible user interactions and scenarios.
2. **Test Execution**: Test cases were executed manually, and the results were documented.
3. **Bug Reporting**: Any discrepancies or bugs found during manual testing were reported and tracked using our issue tracking system.
4. **Regression Testing**: After fixes were implemented, regression testing was conducted to ensure that the issues were resolved and no new issues were introduced.
By combining automated and manual testing, we ensured thorough coverage and reliability of our project, delivering a robust and stable application.

# Build

## Backend server and File Server

The main backend server and file server use Spring Boot framework. Thus, I use maven to manage dependencies and build the two server.

### **Tasks executed in a build (The tasks are**automatically executed in Github Actions**)**

1. Download dependencies: Maven will download dependencies according to `pom.xml` if they are not in the local repository.
2. Compile source code
3. Run test
4. Package: The compiled code will be packed into a `.jar` file.
### Final artifacts

The building process will output a `.jar` executable file for each server. The `.jar` files and jdk environments will be build into Docker images in the deployment step.

### The buildfile

The buildfiles `pom.xml` for the two servers can be found in **backend/pom.xml** and **fileServer/pom.xml**.

## Frontend

The frontend is a Vue project. I use npm to manage the dependencies and use Vite to build artifacts for production.

### **Tasks executed in a build (The tasks are**automatically executed in Github Actions**)**

1. Install dependencies: In this task, the command `npm install` will be executed to download and install the dependencies. A buildfile `package.json` is used to determine the dependencies.
2. Build the frontend for production: In this task, the command `npm build` will be executed to build the source code.
### Final artifacts

The building process will output a folder which contains  `.html`,  `.css`,   `.js` and some other files needed to render the frontend. The folde can be put into Nginx web server to provide service. The folder and Nginx web server will be build into a Docker image in the deployment step.

### The buildfile

The buildfile `package.json` can be found in **frontend/package.json**.

## LLM Service and Recommend Service

The two servers use Python to implement. Thus, the source code does not need to be compiled. They will be build into Docker images directly in the deployment step.

# Deployment

We use Docker to containerize the project. For each component of the system (backend, file server, LLM backend etc), we build it and the environment needed into a Docker image.

Also, we use Github Actions to automatically deploy the project. When someone push some changes to github, the pipeline in Github Actions will run automatically. The test, build and deploy process will be performed in the pipeline.

**The Dockerfiles can be found in the following****directories:**

**Backend:** `backend/Dockerfile`

**File server:** `fileServer/Dockerfile`

**Frontend:** `frontend/Dockerfile`

**LLM service: `**LLM_handler/Dockerfile`

**Recommend service: `**REC/Dockerfile`

**The proof of successful containerization is showed below:**

![](/assets/cicd1.png)

![](/assets/cicd2.png)

**The proof of the successful execution of the pipeline:**

![](/assets/cicd3.png)

